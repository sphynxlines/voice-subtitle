<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>è¯­éŸ³å­—å¹•</title>

  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#000000">
  <link rel="apple-touch-icon" href="/icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="è¯­éŸ³å­—å¹•">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #000;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ç½‘ç»œçŠ¶æ€æç¤ºæ¡ */
    .network-status {
      display: none;
      background: #e74c3c;
      color: #fff;
      text-align: center;
      padding: 10px;
      font-size: 18px;
      font-weight: bold;
    }

    .network-status.offline {
      display: block;
    }

    .subtitle-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
      overflow: hidden; 
      min-height: 0; 
    }

    .subtitle-text {
      font-size: 48px;
      font-weight: bold;
      line-height: 1.5;
      max-width: 100%;
      word-wrap: break-word;
      max-height: 100%;
      overflow-y: auto;
    }

    /* é«˜å¯¹æ¯”åº¦ï¼šæ›´äº®çš„ç°è‰² */
    .recognizing {
      color: #aaa;
    }

    .control-area {
      padding: 30px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      background: #111;
      flex-shrink: 0;
    }

    .btn-start {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: none;
      background: #27ae60;
      color: white;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-start:hover {
      transform: scale(1.05);
    }

    .btn-start:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .btn-start.listening {
      background: #e74c3c;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
      70% { box-shadow: 0 0 0 20px rgba(231, 76, 60, 0); }
      100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
    }

    .status {
      font-size: 18px;
      color: #aaa;
    }

    .font-control {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .help-link {
      width: 50px;
      height: 50px;
      border-radius: 10px;
      border: 2px solid #555;
      background: transparent;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
    }

    .help-link:hover {
      background: #333;
    }
    
    .btn-font {
      width: 50px;
      height: 50px;
      border-radius: 10px;
      border: 2px solid #555;
      background: transparent;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }

    .btn-font:hover {
      background: #333;
    }

    .history {
      max-height: 150px;
      overflow-y: auto;
      width: 100%;
      max-width: 600px;
      padding: 10px;
      font-size: 16px;
      color: #888;
      text-align: center;
    }

    .error {
      color: #e74c3c;
      padding: 20px;
      text-align: center;
    }
  </style>
</head>
<body>

  <!-- ç½‘ç»œçŠ¶æ€æç¤º -->
  <div class="network-status" id="networkStatus">
    âš ï¸ ç½‘ç»œå·²æ–­å¼€
  </div>

  <div class="subtitle-area">
    <div class="subtitle-text" id="subtitleText">
      ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹
    </div>
  </div>

  <div class="control-area">
    <button class="btn-start" id="btnStart" onclick="toggleListening()">
      å¼€å§‹
    </button>
    
    <div class="status" id="status">å‡†å¤‡å°±ç»ª</div>
    
    <div class="font-control">
      <button class="btn-font" onclick="changeFontSize(-8)">A-</button>
      <span id="fontSizeDisplay">48px</span>
      <button class="btn-font" onclick="changeFontSize(8)">A+</button>
      <a href="/help.html" class="help-link" title="å¸®åŠ©">?</a>
    </div>

    <div class="history" id="history"></div>
  </div>

  <!-- Azure Speech SDK -->
  <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>
  
  <script>
    let conversationTranscriber = null;
    let isListening = false;
    let fontSize = 48;
    let wakeLock = null;
    
    const subtitleText = document.getElementById('subtitleText');
    const btnStart = document.getElementById('btnStart');
    const status = document.getElementById('status');
    const history = document.getElementById('history');
    const networkStatus = document.getElementById('networkStatus');

    // è¯´è¯è€…æ˜ å°„ï¼ˆGuest-1 â†’ A, Guest-2 â†’ Bï¼‰
    const speakerMap = {};
    let speakerCount = 0;
    const speakerLabels = ['A', 'B', 'C', 'D', 'E'];

    // ========== å±å¹•å¸¸äº® ==========
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('å±å¹•å¸¸äº®å·²å¯ç”¨');
        }
      } catch (err) {
        console.log('å±å¹•å¸¸äº®ä¸æ”¯æŒ:', err);
      }
    }

    async function releaseWakeLock() {
      if (wakeLock) {
        await wakeLock.release();
        wakeLock = null;
        console.log('å±å¹•å¸¸äº®å·²å…³é—­');
      }
    }

    // é¡µé¢é‡æ–°å¯è§æ—¶æ¢å¤å±å¹•å¸¸äº®
    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'visible' && isListening) {
        await requestWakeLock();
      }
    });

    // ========== éœ‡åŠ¨åé¦ˆ ==========
    function vibrate(duration = 50) {
      if (navigator.vibrate) {
        navigator.vibrate(duration);
      }
    }

    // ========== ç½‘ç»œçŠ¶æ€æ£€æµ‹ ==========
    function updateNetworkStatus() {
      if (navigator.onLine) {
        networkStatus.classList.remove('offline');
      } else {
        networkStatus.classList.add('offline');
        if (isListening) {
          showError('network');
        }
      }
    }

    window.addEventListener('online', () => {
      updateNetworkStatus();
      status.textContent = 'âœ… ç½‘ç»œå·²æ¢å¤';
    });

    window.addEventListener('offline', () => {
      updateNetworkStatus();
    });

    // åˆå§‹åŒ–ç½‘ç»œçŠ¶æ€
    updateNetworkStatus();

    // ========== å‹å¥½çš„é”™è¯¯æç¤º ==========
    function showError(errorType) {
      vibrate(100); // é”™è¯¯æ—¶éœ‡åŠ¨æ›´é•¿
      
      const errorMessages = {
        'network': 'ç½‘ç»œå·²æ–­å¼€ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥',
        'not-allowed': 'è¯·å…è®¸ä½¿ç”¨éº¦å…‹é£',
        'no-audio': 'æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥è®¾å¤‡',
        'token': 'è¿æ¥æœåŠ¡å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
        'init': 'åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•',
        'start': 'å¯åŠ¨å¤±è´¥ï¼Œè¯·é‡æ–°å¼€å§‹',
        'unknown': 'å‡ºé”™äº†ï¼Œè¯·é‡æ–°å¼€å§‹'
      };

      const message = errorMessages[errorType] || errorMessages['unknown'];
      subtitleText.textContent = 'âš ï¸ ' + message;
      status.textContent = 'âŒ ' + message;
    }

    // ========== åŸæœ‰åŠŸèƒ½ ==========
    function getSpeakerLabel(speakerId) {
      if (!speakerMap[speakerId]) {
        speakerMap[speakerId] = speakerLabels[speakerCount] || `è¯´è¯è€…${speakerCount + 1}`;
        speakerCount++;
      }
      return speakerMap[speakerId];
    }

    // è·å– Azure Token
    async function getToken() {
      try {
        if (!navigator.onLine) {
          throw new Error('network');
        }
        const response = await fetch('/api/token');
        if (!response.ok) {
          throw new Error('token');
        }
        return await response.json();
      } catch (error) {
        console.error('Token error:', error);
        throw error;
      }
    }

    // åˆå§‹åŒ– Conversation Transcriber
    async function initTranscriber() {
      status.textContent = 'æ­£åœ¨åˆå§‹åŒ–...';
      
      try {
        const { token, region } = await getToken();
        
        const speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, region);
        speechConfig.speechRecognitionLanguage = 'zh-CN';
        
        const audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
        
        conversationTranscriber = new SpeechSDK.ConversationTranscriber(speechConfig, audioConfig);

        // å®æ—¶è¯†åˆ«ï¼ˆè¯´è¯ä¸­ï¼‰
        conversationTranscriber.transcribing = (s, e) => {
          if (e.result.text) {
            const speaker = e.result.speakerId ? getSpeakerLabel(e.result.speakerId) : '?';
            subtitleText.innerHTML = `<span class="recognizing">${speaker}: ${e.result.text}</span>`;
          }
        };

        // è¯†åˆ«å®Œæˆï¼ˆä¸€å¥è¯è¯´å®Œï¼‰
        conversationTranscriber.transcribed = (s, e) => {
          if (e.result.reason === SpeechSDK.ResultReason.RecognizedSpeech) {
            const speaker = e.result.speakerId ? getSpeakerLabel(e.result.speakerId) : '?';
            const line = `${speaker}: ${e.result.text}`;
            subtitleText.textContent = line;
            addToHistory(line);
          }
        };

        // é”™è¯¯å¤„ç†
        conversationTranscriber.canceled = (s, e) => {
          console.error('Canceled:', e.reason, e.errorDetails);
          if (e.reason === SpeechSDK.CancellationReason.Error) {
            if (e.errorDetails.includes('network')) {
              showError('network');
            } else if (e.errorDetails.includes('microphone') || e.errorDetails.includes('audio')) {
              showError('no-audio');
            } else {
              showError('unknown');
            }
            stopListening();
          }
        };

        conversationTranscriber.sessionStarted = (s, e) => {
          console.log('Session started');
        };

        conversationTranscriber.sessionStopped = (s, e) => {
          console.log('Session stopped');
        };

        return true;
      } catch (error) {
        console.error('Init error:', error);
        if (error.message === 'network') {
          showError('network');
        } else if (error.message === 'token') {
          showError('token');
        } else {
          showError('init');
        }
        return false;
      }
    }

    // åˆ‡æ¢ç›‘å¬çŠ¶æ€
    async function toggleListening() {
      vibrate(); // éœ‡åŠ¨åé¦ˆ
      
      if (isListening) {
        stopListening();
      } else {
        await startListening();
      }
    }

    // å¼€å§‹ç›‘å¬
    async function startListening() {
      // æ£€æŸ¥ç½‘ç»œ
      if (!navigator.onLine) {
        showError('network');
        return;
      }

      btnStart.disabled = true;
      
      // é‡ç½®è¯´è¯è€…æ˜ å°„
      Object.keys(speakerMap).forEach(key => delete speakerMap[key]);
      speakerCount = 0;

      if (!conversationTranscriber) {
        const success = await initTranscriber();
        if (!success) {
          btnStart.disabled = false;
          return;
        }
      }

      try {
        conversationTranscriber.startTranscribingAsync(
          async () => {
            isListening = true;
            btnStart.textContent = 'åœæ­¢';
            btnStart.classList.add('listening');
            btnStart.disabled = false;
            status.textContent = 'ğŸ¤ æ­£åœ¨å¬...';
            subtitleText.textContent = 'æ­£åœ¨å¬...';
            
            // å¯ç”¨å±å¹•å¸¸äº®
            await requestWakeLock();
          },
          (error) => {
            console.error('Start error:', error);
            if (error.toString().includes('Permission') || error.toString().includes('NotAllowed')) {
              showError('not-allowed');
            } else {
              showError('start');
            }
            btnStart.disabled = false;
          }
        );
      } catch (error) {
        console.error('Start error:', error);
        showError('start');
        btnStart.disabled = false;
      }
    }

    // åœæ­¢ç›‘å¬
    async function stopListening() {
      if (conversationTranscriber) {
        conversationTranscriber.stopTranscribingAsync(
          async () => {
            isListening = false;
            btnStart.textContent = 'å¼€å§‹';
            btnStart.classList.remove('listening');
            status.textContent = 'å·²åœæ­¢';
            
            // å…³é—­å±å¹•å¸¸äº®
            await releaseWakeLock();
          },
          (error) => {
            console.error('Stop error:', error);
          }
        );
      }
    }

    // å­—ä½“å¤§å°è°ƒèŠ‚
    function changeFontSize(delta) {
      vibrate(); // éœ‡åŠ¨åé¦ˆ
      fontSize = Math.max(24, Math.min(96, fontSize + delta));
      subtitleText.style.fontSize = fontSize + 'px';
      document.getElementById('fontSizeDisplay').textContent = fontSize + 'px';
    }

    // æ·»åŠ åˆ°å†å²è®°å½•
    function addToHistory(text) {
      if (!text.trim()) return;
      
      const time = new Date().toLocaleTimeString('zh-CN', { 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      const item = document.createElement('div');
      item.textContent = `[${time}] ${text}`;
      history.insertBefore(item, history.firstChild);
      
      while (history.children.length > 10) {
        history.removeChild(history.lastChild);
      }
    }

    // Token è¿‡æœŸåˆ·æ–°ï¼ˆæ¯ 9 åˆ†é’Ÿï¼‰
    setInterval(async () => {
      if (isListening && conversationTranscriber) {
        console.log('Refreshing token...');
        stopListening();
        conversationTranscriber = null;
        await startListening();
      }
    }, 9 * 60 * 1000);
  </script>

</body>
</html>