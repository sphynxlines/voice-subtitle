<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>è¯­éŸ³å­—å¹•</title>

  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#000000">
  <link rel="apple-touch-icon" href="/icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="è¯­éŸ³å­—å¹•">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: #000;
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .subtitle-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      text-align: center;
      overflow: hidden; 
      min-height: 0; 
    }

    .subtitle-text {
      font-size: 48px;
      font-weight: bold;
      line-height: 1.5;
      max-width: 100%;
      word-wrap: break-word;
      max-height: 100%;
      overflow-y: auto;
    }

    .recognizing {
      color: #888;
    }

    .control-area {
      padding: 30px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      background: #111;
      flex-shrink: 0;
    }

    .btn-start {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: none;
      background: #27ae60;
      color: white;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-start:hover {
      transform: scale(1.05);
    }

    .btn-start:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .btn-start.listening {
      background: #e74c3c;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7); }
      70% { box-shadow: 0 0 0 20px rgba(39, 174, 96, 0); }
      100% { box-shadow: 0 0 0 0 rgba(39, 174, 96, 0); }
    }

    .status {
      font-size: 18px;
      color: #888;
    }

    .font-control {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    .btn-font {
      width: 50px;
      height: 50px;
      border-radius: 10px;
      border: 2px solid #444;
      background: transparent;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }

    .btn-font:hover {
      background: #333;
    }

    .history {
      max-height: 150px;
      overflow-y: auto;
      width: 100%;
      max-width: 600px;
      padding: 10px;
      font-size: 16px;
      color: #666;
      text-align: center;
    }

    .error {
      color: #e74c3c;
      padding: 20px;
      text-align: center;
    }
  </style>
</head>
<body>

  <div class="subtitle-area">
    <div class="subtitle-text" id="subtitleText">
      ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹
    </div>
  </div>

  <div class="control-area">
    <button class="btn-start" id="btnStart" onclick="toggleListening()">
      å¼€å§‹
    </button>
    
    <div class="status" id="status">å‡†å¤‡å°±ç»ª</div>
    
    <div class="font-control">
      <button class="btn-font" onclick="changeFontSize(-8)">A-</button>
      <span id="fontSizeDisplay">48px</span>
      <button class="btn-font" onclick="changeFontSize(8)">A+</button>
    </div>

    <div class="history" id="history"></div>
  </div>

  <!-- Azure Speech SDK -->
  <script src="https://aka.ms/csspeech/jsbrowserpackageraw"></script>
  
<script>
  let conversationTranscriber = null;
  let isListening = false;
  let fontSize = 48;
  
  const subtitleText = document.getElementById('subtitleText');
  const btnStart = document.getElementById('btnStart');
  const status = document.getElementById('status');
  const history = document.getElementById('history');

  // è¯´è¯è€…æ˜ å°„ï¼ˆGuest-1 â†’ A, Guest-2 â†’ Bï¼‰
  const speakerMap = {};
  let speakerCount = 0;
  const speakerLabels = ['A', 'B', 'C', 'D', 'E'];

  function getSpeakerLabel(speakerId) {
    if (!speakerMap[speakerId]) {
      speakerMap[speakerId] = speakerLabels[speakerCount] || `è¯´è¯è€…${speakerCount + 1}`;
      speakerCount++;
    }
    return speakerMap[speakerId];
  }

  // èŽ·å– Azure Token
  async function getToken() {
    try {
      const response = await fetch('/api/token');
      if (!response.ok) {
        throw new Error('Failed to get token');
      }
      return await response.json();
    } catch (error) {
      console.error('Token error:', error);
      throw error;
    }
  }

  // åˆå§‹åŒ– Conversation Transcriber
  async function initTranscriber() {
    status.textContent = 'æ­£åœ¨åˆå§‹åŒ–...';
    
    try {
      const { token, region } = await getToken();
      
      const speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, region);
      speechConfig.speechRecognitionLanguage = 'zh-CN';
      
      const audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
      
      conversationTranscriber = new SpeechSDK.ConversationTranscriber(speechConfig, audioConfig);

      // å®žæ—¶è¯†åˆ«ï¼ˆè¯´è¯ä¸­ï¼‰
      conversationTranscriber.transcribing = (s, e) => {
        if (e.result.text) {
          const speaker = e.result.speakerId ? getSpeakerLabel(e.result.speakerId) : '?';
          subtitleText.innerHTML = `<span class="recognizing">${speaker}: ${e.result.text}</span>`;
        }
      };

      // è¯†åˆ«å®Œæˆï¼ˆä¸€å¥è¯è¯´å®Œï¼‰
      conversationTranscriber.transcribed = (s, e) => {
        if (e.result.reason === SpeechSDK.ResultReason.RecognizedSpeech) {
          const speaker = e.result.speakerId ? getSpeakerLabel(e.result.speakerId) : '?';
          const line = `${speaker}: ${e.result.text}`;
          subtitleText.textContent = line;
          addToHistory(line);
        }
      };

      // é”™è¯¯å¤„ç†
      conversationTranscriber.canceled = (s, e) => {
        console.error('Canceled:', e.reason, e.errorDetails);
        if (e.reason === SpeechSDK.CancellationReason.Error) {
          status.textContent = 'âŒ é”™è¯¯: ' + e.errorDetails;
          stopListening();
        }
      };

      conversationTranscriber.sessionStarted = (s, e) => {
        console.log('Session started');
      };

      conversationTranscriber.sessionStopped = (s, e) => {
        console.log('Session stopped');
      };

      return true;
    } catch (error) {
      console.error('Init error:', error);
      status.textContent = 'âŒ åˆå§‹åŒ–å¤±è´¥: ' + error.message;
      return false;
    }
  }

  // åˆ‡æ¢ç›‘å¬çŠ¶æ€
  async function toggleListening() {
    if (isListening) {
      stopListening();
    } else {
      await startListening();
    }
  }

  // å¼€å§‹ç›‘å¬
  async function startListening() {
    btnStart.disabled = true;
    
    // é‡ç½®è¯´è¯è€…æ˜ å°„
    Object.keys(speakerMap).forEach(key => delete speakerMap[key]);
    speakerCount = 0;

    if (!conversationTranscriber) {
      const success = await initTranscriber();
      if (!success) {
        btnStart.disabled = false;
        return;
      }
    }

    try {
      conversationTranscriber.startTranscribingAsync(
        () => {
          isListening = true;
          btnStart.textContent = 'åœæ­¢';
          btnStart.classList.add('listening');
          btnStart.disabled = false;
          status.textContent = 'ðŸŽ¤ æ­£åœ¨å¬...';
          subtitleText.textContent = 'æ­£åœ¨å¬...';
        },
        (error) => {
          console.error('Start error:', error);
          status.textContent = 'âŒ å¯åŠ¨å¤±è´¥: ' + error;
          btnStart.disabled = false;
        }
      );
    } catch (error) {
      console.error('Start error:', error);
      status.textContent = 'âŒ å¯åŠ¨å¤±è´¥';
      btnStart.disabled = false;
    }
  }

  // åœæ­¢ç›‘å¬
  function stopListening() {
    if (conversationTranscriber) {
      conversationTranscriber.stopTranscribingAsync(
        () => {
          isListening = false;
          btnStart.textContent = 'å¼€å§‹';
          btnStart.classList.remove('listening');
          status.textContent = 'å·²åœæ­¢';
        },
        (error) => {
          console.error('Stop error:', error);
        }
      );
    }
  }

  // å­—ä½“å¤§å°è°ƒèŠ‚
  function changeFontSize(delta) {
    fontSize = Math.max(24, Math.min(96, fontSize + delta));
    subtitleText.style.fontSize = fontSize + 'px';
    document.getElementById('fontSizeDisplay').textContent = fontSize + 'px';
  }

  // æ·»åŠ åˆ°åŽ†å²è®°å½•
  function addToHistory(text) {
    if (!text.trim()) return;
    
    const time = new Date().toLocaleTimeString('zh-CN', { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    const item = document.createElement('div');
    item.textContent = `[${time}] ${text}`;
    history.insertBefore(item, history.firstChild);
    
    while (history.children.length > 10) {
      history.removeChild(history.lastChild);
    }
  }

  // Token è¿‡æœŸåˆ·æ–°ï¼ˆæ¯ 9 åˆ†é’Ÿï¼‰
  setInterval(async () => {
    if (isListening && conversationTranscriber) {
      console.log('Refreshing token...');
      stopListening();
      conversationTranscriber = null;
      await startListening();
    }
  }, 9 * 60 * 1000);
</script>

</body>
</html>